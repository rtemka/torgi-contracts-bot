package bot

import (
	"flag"
	"fmt"
	"log"
	"strconv"
	"strings"
	botDB "tbot/pkg/db"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api"
)

// bot message
const (
	unknownMsg     = `–ò–∑–≤–∏–Ω–∏, –Ω–µ –∑–Ω–∞—é —Ç–∞–∫–æ–π –∫–æ–º–∞–Ω–¥—ã\. –ü–æ–ø—Ä–æ–±—É–π ‚û°Ô∏è */help*`
	errorMsg       = "–ò–∑–≤–∏–Ω–∏ üò•, –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∫–æ–º–∞–Ω–¥—É"
	invalidArgsMsg = "–ò–∑–≤–∏–Ω–∏, –¥–ª—è –∫–æ–º–∞–Ω–¥—ã –≤–≤–µ–¥–µ–Ω—ã –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã ü§∑\n" +
		`‚û°Ô∏è */help* \-\[*_–∏–º—è –∫–æ–º–∞–Ω–¥—ã_*\]`
	hiMsg          = "–ü—Ä–∏–≤–µ—Ç üëã ‚û°Ô∏è */help* –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏"
	startMsg       = "–ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ ‚öíÔ∏è"
	statusMsg      = "–í—Å–µ –æ–∫\\!"
	errorOptionMsg = "–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –æ–ø—Ü–∏—è –∫–æ–º–∞–Ω–¥—ã\n" + `‚û°Ô∏è */help* \-\[*_–∏–º—è –∫–æ–º–∞–Ω–¥—ã_*\]` +
		"\n–¥–ª—è —Å–ø—Ä–∞–≤–∫–∏ –ø–æ –∫–æ–º–∞–Ω–¥–µ"
	notFoundIdMsg = "–ù–µ –Ω–∞—à–µ–ª –Ω–∏—á–µ–≥–æ –ø–æ –∑–∞–¥–∞–Ω–Ω–æ–º—É id"
	notAllowedMsg = "–ò–∑–≤–∏–Ω–∏, –Ω–µ –æ—Ç–≤–µ—á–∞—é —Ç–µ–º, –∫–æ–≥–æ –Ω–µ –∑–Ω–∞—é"
)

// command help message
const (
	generalHelpMsg = `*–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:*` + "\n\n" +
		`*/` + todayCmd + `* \- –∞—É–∫—Ü–∏–æ–Ω—ã‚öîÔ∏è / –∑–∞—è–≤–∫–∏üîú —Å–µ–≥–æ–¥–Ω—è` + "\n\n" +
		`*/` + futureCmd + `* \- –∞—É–∫—Ü–∏–æ–Ω—ã/–∑–∞—è–≤–∫–∏/–æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –≤ –±—É–¥—É—â–µ–º üîÆ` + "\n\n" +
		`*/` + pastCmd + `* \- —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞–∫—É–ø–æ–∫ ‚ö∞Ô∏è` + "\n\n" +
		`*/` + infoCmd + `* \- –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ –∑–∞–∫—É–ø–∫–µ üìù` + "\n\n" +
		"–ü–æ–¥—Ä–æ–±–Ω–µ–µ –æ –∫–∞–∂–¥–æ–π –∫–æ–º–∞–Ω–¥–µ:" + "\n" + `*/` + helpCmd + `* \-\[*_–∏–º—è –∫–æ–º–∞–Ω–¥—ã_*\]`
	todayHelpMsg = `*–ò–º—è –∫–æ–º–∞–Ω–¥—ã:       /` + todayCmd + "\n" + `–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:   /` + todayCmd + `*    \[*_–æ–ø—Ü–∏–∏_*\]\.\.\.` +
		"\n" + `*–û–ø–∏—Å–∞–Ω–∏–µ:*` + "\n" + `*/` + todayCmd + `* –∑–Ω–∞—á–∏—Ç '*_today_*' —Ç\.–µ '*_—Å–µ–≥–æ–¥–Ω—è_*'` +
		"\n–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –≤—Å–µ –æ–∂–∏–¥–∞–µ–º—ã–µ —Å–µ–≥–æ–¥–Ω—è —Ç–æ—Ä–≥–∏ –∏ –∑–∞—è–≤–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –ø–æ–¥–∞—Ç—å\n" +
		`*–û–ø—Ü–∏–∏:*` + "\n" + `*_\-` + auctionKey + `, \-` + auctionKeyLong + `_*    ` + auctionKeyUsg + "\n" +
		`*_\-` + goKey + `, \-` + goKeyLong + `_*           ` + goKeyUsg
	futureHelpMsg = `*–ò–º—è –∫–æ–º–∞–Ω–¥—ã:       /` + futureCmd + "\n" + `–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:   /` + futureCmd + `*    \[*_–æ–ø—Ü–∏–∏_*\]\.\.\. *_\=NUM_*` +
		"\n" + `*–û–ø–∏—Å–∞–Ω–∏–µ:*` + "\n" + `*/` + futureCmd + `* –∑–Ω–∞—á–∏—Ç '*_future_*' —Ç\.–µ '*_–±—É–¥—É—â–µ–µ_*'` +
		"\n–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –≤—Å–µ –±—É–¥—É—â–∏–µ –∞—É–∫—Ü–∏–æ–Ω—ã –∏ –∑–∞—è–≤–∫–∏, –∞ —Ç–∞–∫–∂–µ —Å—É–º–º—ã –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –∑–∞—è–≤–æ–∫\n" +
		`*–û–ø—Ü–∏–∏:*` + "\n" + `*_\-` + auctionKey + `, \-` + auctionKeyLong + `_*    ` + auctionKeyUsg + "\n" +
		`*_\-` + goKey + `, \-` + goKeyLong + `_*           ` + goKeyUsg + "\n" +
		`*_\-` + moneyKey + `, \-` + moneyKeyLong + `_*       ` + moneyKeyUsg + "\n" +
		`*_\-` + daysKey + `, \-` + daysKeyLong + `\=NUM_* ` + daysKeyUsg + " –≤–ø–µ—Ä–µ–¥"
	pastHelpMsg = `*–ò–º—è –∫–æ–º–∞–Ω–¥—ã:       /` + pastCmd + "\n" + `–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:   /` + pastCmd + `*    \[*_–æ–ø—Ü–∏–∏_*\]\.\.\. *_\=NUM_*` +
		"\n" + `*–û–ø–∏—Å–∞–Ω–∏–µ:*` + "\n" +
		`*/` + pastCmd + `* –∑–Ω–∞—á–∏—Ç '*_past_*' —Ç\.–µ '*_–ø—Ä–æ—à–ª–æ–µ_*'` + "\n–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–æ—à–µ–¥—à–∏—Ö –∑–∞–∫—É–ø–æ–∫\n" +
		`*–û–ø—Ü–∏–∏:*` + "\n" + `*_\-` + daysKey + `, \-` + daysKeyLong + `\=NUM_* ` + daysKeyUsg + " –Ω–∞–∑–∞–¥"
	infoHelpMsg = `*–ò–º—è –∫–æ–º–∞–Ω–¥—ã:      /` + infoCmd + "\n" + `–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:   /` + infoCmd + `    \=ID*` +
		"\n" + `*–û–ø–∏—Å–∞–Ω–∏–µ:*` + "\n" + `*/` + infoCmd + `* –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∑–∞–∫—É–ø–∫–µ` + "\n" +
		`–í –≤—ã–≤–æ–¥–µ –¥—Ä—É–≥–∏—Ö –∫–æ–º–∞–Ω–¥ –µ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–µ \[*_ID_*\]\.` + "\n" +
		`–≠—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ –∫–∞–∫ –∞—Ä–≥—É–º–µ–Ω—Ç –¥–ª—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã —Ç\.–µ '*/` + infoCmd + `  _ID_'*`
	cmdHelp = "–ø–æ–º–æ—â—å –ø–æ –∫–æ–º–∞–Ω–¥–µ /"
)

// bot command
const (
	todayCmd  = "t"
	futureCmd = "f"
	pastCmd   = "p"
	infoCmd   = "i"
	helpCmd   = "help"
	statusCmd = "status"
	startCmd  = "start"
	hiCmd     = "hi"
	chatCmd   = "chat"
)

// bot command key
const (
	auctionKey     = "a"
	auctionKeyLong = "auction"
	goKey          = "g"
	goKeyLong      = "go"
	moneyKey       = "m"
	moneyKeyLong   = "money"
	daysKey        = "d"
	daysKeyLong    = "days"
)

// key usage
const (
	auctionKeyUsg = "–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∞—É–∫—Ü–∏–æ–Ω—ã"
	goKeyUsg      = "–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∑–∞—è–≤–∫–∏"
	moneyKeyUsg   = "–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—É–º–º—ã –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è"
	daysKeyUsg    = "–æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç –≤—ã–±–æ—Ä–∫—É –Ω–∞ NUM –¥–Ω–µ–π"
)

// querier is responsible
// for the retrieving info from database
type querier interface {
	Query(int, ...botDB.QueryOpt) ([]botDB.PurchaseRecord, error)
	QueryRow(int64) (botDB.PurchaseRecord, error)
}

// tgUpdHandler processes incoming telegram updates
type tgUpdHandler struct {
	logger *log.Logger
	api    *tgbotapi.BotAPI
	q      querier
	chats  map[int64]bool
}

func newTgUpdHandler(logger *log.Logger, q querier,
	api *tgbotapi.BotAPI, allowedChats map[int64]bool) *tgUpdHandler {
	return &tgUpdHandler{
		logger: logger,
		q:      q,
		api:    api,
		chats:  allowedChats,
	}
}

// handleUpdate redirects incoming update to appropriate handler
func (t *tgUpdHandler) handleUpdate(u *tgbotapi.Update) {
	if !u.Message.IsCommand() {
		return
	}

	// restricted access
	if !t.chats[u.Message.Chat.ID] {
		t.logger.Printf("[Telegram] -> [chatID=%d from=%v; restricted access]",
			u.Message.Chat.ID, u.Message.From)
		if err := send(t.api, u.Message.Chat.ID, t.notAllowed(u.Message)); err != nil {
			t.logger.Println(err)
		}
		return
	}

	log.Printf("[Telegram] -> [received: chatID=%d from=%v text=%s]",
		u.Message.Chat.ID, u.Message.From, u.Message.Text)

	// we parse flags from this message as if it was
	// command line arguments
	flags, err := parseMsgArgs(u.Message.CommandArguments())
	if err != nil {
		t.logger.Printf("[Telegram] -> [due parsing message arguments %v]", err)
		if err = send(t.api, u.Message.Chat.ID, errorOptionMsg); err != nil {
			t.logger.Println(err)
		}
		return
	}

	// get responses from command handlers
	msgs := t.responses(u, flags)

	// sending responses
	if err = send(t.api, u.Message.Chat.ID, msgs...); err != nil {
		t.logger.Println(err)
	}
}

func (t *tgUpdHandler) responses(u *tgbotapi.Update, flags *flags) []string {
	// choosing appropriate handler
	switch u.Message.Command() {
	case todayCmd:
		return t.todayCmdResponse(flags)
	case futureCmd:
		return t.futureCmdResponse(flags)
	case pastCmd:
		return t.pastCmdResponse(flags)
	case helpCmd:
		return t.helpCmdResponse(flags)
	case infoCmd:
		return t.infoCmdResponse(flags)
	case startCmd:
		return []string{startMsg}
	case statusCmd:
		return []string{statusMsg}
	case hiCmd:
		return []string{t.hiCmdResponse(u.Message)}
	case chatCmd:
		return []string{fmt.Sprint(u.Message.Chat.ID)}
	default:
		return []string{unknownMsg}
	}
}

// parseMsgArgs inspects provided arguments
// and returns parsed flags or error
func parseMsgArgs(args string) (*flags, error) {
	var s []string
	if args != "" {
		// we split incoming message command arguments
		s = strings.Split(args, " ")
	}
	// then we parse flags from this message as if it was
	// command line arguments
	// if args is empty we pass a nil slice
	return parseFlags(s)
}

// flags holds flag set and all expected flags
type flags struct {
	set                         *flag.FlagSet
	tf, ff, pf, af, gf, mf, inf bool
	df                          int
}

// parseFlags parses expected flags to the flags struct
func parseFlags(args []string) (*flags, error) {
	f := flags{}
	f.set = flag.NewFlagSet("bot flag set", flag.ContinueOnError)
	if len(args) == 0 {
		return &f, nil // if no arguments provided we don't parsing
	}

	f.set.BoolVar(&f.tf, todayCmd, false, cmdHelp+todayCmd)
	f.set.BoolVar(&f.ff, futureCmd, false, cmdHelp+futureCmd)
	f.set.BoolVar(&f.pf, pastCmd, false, cmdHelp+pastCmd)
	f.set.BoolVar(&f.af, auctionKey, false, auctionKeyUsg)
	f.set.BoolVar(&f.gf, goKey, false, goKeyUsg)
	f.set.BoolVar(&f.af, auctionKeyLong, false, auctionKeyUsg)
	f.set.BoolVar(&f.gf, goKeyLong, false, goKeyUsg)
	f.set.BoolVar(&f.mf, moneyKey, false, moneyKeyUsg)
	f.set.BoolVar(&f.mf, moneyKeyLong, false, moneyKeyUsg)
	f.set.BoolVar(&f.inf, infoCmd, false, cmdHelp+infoCmd)
	f.set.IntVar(&f.df, daysKey, 0, daysKeyUsg)
	f.set.IntVar(&f.df, daysKeyLong, 0, daysKeyUsg)
	err := f.set.Parse(args)
	if err != nil {
		return &f, err
	}

	return &f, nil
}

// hiCmdResponse is the '/hi' command handler
func (t *tgUpdHandler) hiCmdResponse(m *tgbotapi.Message) string {
	if m.From.FirstName != "" {
		return fmt.Sprintf("–ü—Ä–∏–≤–µ—Ç, %s üëã\n‚û°Ô∏è */help* –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏", m.From.FirstName)
	} else if m.From.UserName != "" {
		return fmt.Sprintf("–ü—Ä–∏–≤–µ—Ç, %s üëã\n‚û°Ô∏è */help* –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏", m.From.UserName)
	} else {
		return "–ü—Ä–∏–≤–µ—Ç üëã\n‚û°Ô∏è */help* –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏"
	}
}

// notAllowed is response for unauthorized request
func (t *tgUpdHandler) notAllowed(m *tgbotapi.Message) string {
	if m.From.FirstName != "" {
		return fmt.Sprintf("–ü—Ä–∏–≤–µ—Ç, %s üëã\n%s", m.From.FirstName, notAllowedMsg)
	} else if m.From.UserName != "" {
		return fmt.Sprintf("–ü—Ä–∏–≤–µ—Ç, %s üëã\n%s", m.From.UserName, notAllowedMsg)
	} else {
		return notAllowedMsg
	}
}

// unknownArgsErr returns error message when
// input arguments contains some garbage leftovers
func unknownArgsErr(f *flags) []string {
	return []string{fmt.Sprintf("–ü–µ—Ä–µ–¥–∞–Ω—ã –Ω–µ–ø–æ–Ω—è—Ç–Ω—ã–µ –¥–ª—è –º–µ–Ω—è –∞—Ä–≥—É–º–µ–Ω—Ç—ã ‚û°Ô∏è %v", f.set.Args())}
}

// helpCmdResponse is the '/help' command handler
func (t *tgUpdHandler) helpCmdResponse(f *flags) []string {

	if f.set.NFlag() == 0 {
		return []string{generalHelpMsg}
	}

	msg := make([]string, 0, f.set.NFlag())

	if f.tf {
		msg = append(msg, todayHelpMsg)
	}
	if f.ff {
		msg = append(msg, futureHelpMsg)
	}
	if f.pf {
		msg = append(msg, pastHelpMsg)
	}
	if f.inf {
		msg = append(msg, infoHelpMsg)
	}

	return msg
}

// todayCmdResponse is the '/t' command handler
func (t *tgUpdHandler) todayCmdResponse(f *flags) []string {

	// check for the garbage in arguments
	if f.set.NArg() > 0 {
		return unknownArgsErr(f)
	}

	if f.set.NFlag() == 0 {
		return t.query(0, botDB.Today)
	}

	opts := make([]botDB.QueryOpt, 0, f.set.NFlag())

	if f.af {
		opts = append(opts, botDB.TodayAuction)
	}
	if f.gf {
		opts = append(opts, botDB.TodayGo)
	}

	return t.query(0, opts...)
}

// futureCmdResponse is the '/f' command handler
func (t *tgUpdHandler) futureCmdResponse(f *flags) []string {

	// check for the garbage in arguments
	if f.set.NArg() > 0 {
		return unknownArgsErr(f)
	}

	opts := make([]botDB.QueryOpt, 0, f.set.NFlag())

	if f.af {
		opts = append(opts, botDB.FutureAuction)
	}
	if f.gf {
		opts = append(opts, botDB.FutureGo)
	}
	if f.mf {
		opts = append(opts, botDB.FutureMoney)
	}

	if len(opts) == 0 {
		opts = append(opts, botDB.Future)
	}

	return t.query(f.df, opts...)
}

// infoCmdResponse is the '/i' command handler
func (t *tgUpdHandler) infoCmdResponse(f *flags) []string {

	// we expecting only one argument which is id
	if f.set.NArg() != 1 {
		return []string{invalidArgsMsg}
	}

	id, err := strconv.ParseInt(f.set.Arg(0), 10, 0)
	if err != nil {
		t.logger.Printf("[Telegram] -> [due converting id %v]", err)
		return []string{errorMsg}
	}

	p, err := t.q.QueryRow(id)
	if err != nil {
		if err == botDB.ErrNoRows {
			return []string{notFoundIdMsg}
		}
		t.logger.Printf("[Telegram] -> [due fetching record %v]", err)
		return []string{errorMsg}
	}

	return buildMessages(p)
}

// pastCmdResponse is the '/p' command handler
func (t *tgUpdHandler) pastCmdResponse(f *flags) []string {
	// check for the garbage in arguments
	if f.set.NArg() > 0 {
		return unknownArgsErr(f)
	}

	return t.query(f.df, botDB.Past)
}

// query is the helper method that transmits
// options to database handler and then
// passes results to the message builder
func (t *tgUpdHandler) query(daysLimit int, opts ...botDB.QueryOpt) []string {

	recs, err := t.q.Query(daysLimit, opts...) // gets results
	if err != nil {
		t.logger.Printf("[Telegram] -> [due fetching records %v]", err)
		return []string{errorMsg}
	}

	return buildMessages(recs...) // passes results
}
